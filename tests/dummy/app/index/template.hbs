<div class="container">
  <section class="header">
    <h4 class="centered">
      <strong>ember-concurrency</strong> is an <strong>Ember Addon</strong> that enables
      you to write concise, worry-free, cancelable, restartable, asynchronous tasks.
    </h4>
  </section>

  <section class="header">
    <h5 class="centered">
      Read the
      <a href="https://medium.com/@machty/ember-concurrency-the-solution-to-so-many-problems-you-never-knew-you-had-cce6d7731ba9#.9xtqpsu31">
        blog post
      </a>
      for a high-level view of what ember-concurrency can do for your app.
    </h5>
  </section>

  <section>
    <h2 class="centered">Basic Example</h2>

    <div class="row">
      <div class="six columns">
        <h3>{{caps-marquee text="ember-concurrency"}}</h3>

        {{code-snippet name="caps-marquee.js"}}
      </div>
      <div class="six columns">
        <h3>{{scrambled-text text="ember-concurrency"}}</h3>

        {{code-snippet name="scrambled-text.js"}}
      </div>
    </div>

    <h5>
      Imagine writing the above using timers (or Promises):
    </h5>

    <ul>
      <li>You would need to use <strong>callbacks</strong></li>
      <li>These callbacks would require some sort of <strong>recursive call</strong>
          to take the next "step"</li>
      <li>You would need to implement <strong>lifecycle hooks</strong> to stop the animation
          when the component is unrendered</li>
      <li>You would need to <strong>cancel timers</strong> and in some cases add
          <code>if (this.isDestroyed)</code> guards to your callbacks
          to prevent out-of-bounds errors (such as
          <em>"Assertion Failed: calling set on destroyed object"</em>)
      </li>
    </ul>

    <p>
      By leveraging generator function syntax (<code>function *</code> and the
      <code>yield</code> keyword), <strong>ember-concurrency</strong> lets you
      write <strong>extremely clear asynchronous code</strong> and takes care of all the messy stuff:
      tearing down asynchronous tasks (and <strong>canceling</strong> them where possible, 
      e.g. <strong>AJAX requests</strong>), scoping asynchronous tasks to the lifetime
      of the object they live on (e.g. Components), and preventing undesired
      concurrency between tasks.
    </p>

    <h5>
      But that's just the beginning...
    </h5>

    <p>
      Please take a look at the {{link-to 'documentation' 'docs'}} to discover all the ways
      ember-concurrency can help.
    </p>
  </section>
</div>

