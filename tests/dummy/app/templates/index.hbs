
<p>
  <a href="https://github.com/machty/ember-concurrency/tree/master/tests/dummy/app" target="_blank">Check out the code</a>
</p>



<div class="container">
  <section class="header">
    <h1>ember-concurrency</h1>

    <h4 class="centered"><strong>ember-concurrency</strong> is an <strong>Ember Addon</strong> that enables you to:</h4>

    <div class="row">
      <div class="four columns">
        Use an <strong>Async/Await-like syntax</strong> to easily express complex,
        <strong>cancellable</strong>, and <strong>restartable</strong> tasks.
      </div>
      <div class="four columns">
        <strong>Say goodbye to error-prone boilerplate</strong> for managing asynchrony, including:
        timer cancellation, deactivate &amp; willDestroy hooks,
        isDestroyed checks, and others.
      </div>
      <div class="four columns">
        Loop over streams of <strong>Ember.Evented</strong> events
        (and optionally <strong>Rx.Observables</strong>), with
        built-in <strong>backpressure</strong> support, and no
        <strong>Callback Hell</strong>&trade;.
      </div>
    </div>
  </section>

  <section>
    <h2 class="centered">Basic Example</h2>

    <div class="row">
      <div class="six columns">
        <h3>{{caps-marquee text="ember-concurrency"}}</h3>

        {{code-snippet name="caps-marquee.js"}}
      </div>
      <div class="six columns">
        <h3>{{scrambled-text text="ember-concurrency"}}</h3>

        {{code-snippet name="scrambled-text.js"}}
      </div>
    </div>

    <h5>
      Imagine writing the above using timers:
    </h5>

    <ul>
      <li>You would need to use <strong>callbacks</strong></li>
      <li>These callbacks would require some sort of <strong>recursive call</strong>
          to take the next "step"</li>
      <li>You would need to implement <strong>lifecycle hooks</strong> to stop the animation
          when the component is unrendered</li>
      <li>You would need to <strong>cancel timers</strong> and in some cases add
          <code>if (this.isDestroyed)</code> guards to your callbacks
          to prevent out-of-bounds errors (such as
          <code>"Assertion Failed: calling set on destroyed object"</code>)
      </li>
    </ul>

    <p>
      By leveraging generator function syntax (<code>function *</code> and the
      <code>yield</code> keyword), <strong>ember-concurrency</strong> let's you
      write <strong>extremely clear asynchronous code</strong> and takes care of all the messy stuff:
      tearing down asynchronous tasks (and <code>cancelling</code> them where possible, 
      e.g. <code>AJAX requests</code>), scoping asynchronous tasks to the lifetime
      of the object they live on (e.g. Components), and preventing undesired
      concurrency between tasks.
    </p>

    <h5>
      But that's just the beginning...
    </h5>

    <p>
      Please take a look at the documentation to discover all the ways
      ember-concurrency can help.
    </p>
  </section>
</div>

