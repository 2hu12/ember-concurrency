<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: -task-instance.js</title>

    <script src="scripts/prettify/prettify-709bfcc456c694bfe8ee86d184a1c360.js" integrity="sha256-4uV247xgfNF5/1EZRwEPZF00QaNTE67A29BsRDf4O3c= sha512-cWK7m0Z2gnQvbYfqlDAAAAZPxU4VGTw9flpPiY8K191VutjwGTPrYlqxoPSoGR1wYuGsvsZRLuYQ0sDEE8CzSg==" > </script>
    <script src="scripts/prettify/lang-css-914365fa44cd3c094afc7c0de229e29e.js" integrity="sha256-m2rEgwM7AlcnFOtNN+4ZkYXEEAjrKz9GoAqw685qIMU= sha512-I7qoWRmUBxiLMXpr0MqXWzZaRC7iYXw6t1j9IRkcGqaFQiOkRd4l8rIPpIvTtqB+IZ82fVjCAGGymC7nBXj/Bw==" > </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow-3559834dc32d2cad6adeb2d2fed40e18.css" integrity="sha256-zInEqaMwHPE1XRPTqnMP2uZOEEYFQ2zjcasAv2R1nXg= sha512-DNQDuSSkAzc46N+QWE3KS1L9bV0TmwsRxFLYlC6kX3SP8nJmMl/33DgpGRmNKkm+TppbqCWXPhhin5iHk2K+WQ==" >
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default-ae260dbf3da9b55f508cf5f0e0692c75.css" integrity="sha256-Lt+BUW2LloVa18IoHxlqx0pFWuFeX5uiMj/ZgL1XtZs= sha512-Ck58In4yxY9dQKwfz4hzsWRvZ5vJelyCE4fHt+Sdx4zSss8NZPCeYlfY4+vioLHuVLB3YAtTKApR6L1jV7+HJQ==" >
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: -task-instance.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Ember from 'ember';
import { createObservable } from './utils';

function forwardToInternalPromise(method) {
  return function(...args) {
    this._ignorePromiseErrors = true;
    return this._defer.promise[method](...args);
  };
}


/**
  A `TaskInstance` represent a single execution of a
  {@linkcode Task}. Every call to {@linkcode Task#perform} returns
  a `TaskInstance`.

  `TaskInstance`s are cancelable, either explicitly
  via {@linkcode TaskInstance#cancel} or {@linkcode Task#cancelAll},
  or automatically due to the host object being destroyed, or
  because concurrency policy enforced by a
  {@linkcode TaskProperty Task Modifier} canceled the task instance.

  &lt;style>
    .ignore-this--this-is-here-to-hide-constructor,
    #TaskInstance { display: none }
  &lt;/style>

  @class TaskInstance
*/
let TaskInstance = Ember.Object.extend({
  iterator: null,
  _disposable: null,
  _ignorePromiseErrors: false,

  /**
   * True if the task instance was canceled before it could run to completion.
   *
   * @memberof TaskInstance
   * @instance
   * @readOnly
   */
  isCanceled: false,

  /**
   * True if the task instance has started, else false.
   *
   * @memberof TaskInstance
   * @instance
   * @readOnly
   */
  hasStarted: false,

  /**
   * True if the task has run to completion.
   *
   * @memberof TaskInstance
   * @instance
   * @readOnly
   */
  isFinished: false,

  /**
   * True if the task is still running.
   *
   * @memberof TaskInstance
   * @instance
   * @readOnly
   */
  isRunning: Ember.computed.not('isFinished'),

  /**
   * Describes the state that the task instance is in. Can be used for debugging,
   * or potentially driving some UI state. Possible values are:
   *
   * - `"dropped"`: task instance was canceled before it started
   * - `"canceled"`: task instance was canceled before it could finish
   * - `"finished"`: task instance ran to completion (even if an exception was thrown)
   * - `"running"`: task instance is currently running (returns true even if
   *     is paused on a yielded promise)
   * - `"waiting"`: task instance hasn't begun running yet (usually
   *     because the task is using the {@linkcode TaskProperty#enqueue .enqueue()}
   *     task modifier)
   *
   * The animated timeline examples on the [Task Concurrency](/#/docs/task-concurrency)
   * docs page make use of this property.
   *
   * @memberof TaskInstance
   * @instance
   * @readOnly
   */
  state: Ember.computed('isDropped', 'isCanceled', 'hasStarted', 'isFinished', function() {
    if (this.get('isDropped')) {
      return 'dropped';
    } else if (this.get('isCanceled')) {
      return 'canceled';
    } else if (this.get('isFinished')) {
      return 'finished';
    } else if (this.get('hasStarted')) {
      return 'running';
    } else {
      return 'waiting';
    }
  }),

  /**
   * True if the TaskInstance was canceled before it could
   * ever start running. For example, calling
   * {@linkcode Task#perform .perform()} twice on a
   * task with the {@linkcode TaskProperty#drop .drop()} modifier applied
   * will result in the second task instance being dropped.
   *
   * @memberof TaskInstance
   * @instance
   * @readOnly
   */
  isDropped: Ember.computed('isCanceled', 'hasStarted', function() {
    return this.get('isCanceled') &amp;&amp; !this.get('hasStarted');
  }),

  _index: 1,

  init() {
    this._super();
    this._defer = Ember.RSVP.defer();
    this._cancelationIgnorer = this._defer.promise.catch(e => {
      if (this._ignorePromiseErrors) { return; }

      if (e &amp;&amp; e.name === 'TaskCancelation' &amp;&amp; e.taskInstance === this) {
        // swallow cancelations that belong to the same task.
      } else {
        return Ember.RSVP.reject(e);
      }
    });
    this.iterator = this.fn.apply(this.context, this.args);
  },

  _start() {
    if (this.hasStarted || this.isCanceled) { return this; }
    this.set('hasStarted', true);
    this._proceed(1, undefined);
    return this;
  },

  /**
   * Cancels the task instance. Has no effect if the task instance has
   * already been canceled or has already finished running.
   *
   * @method cancel
   * @memberof TaskInstance
   * @instance
   */
  cancel() {
    if (this.isCanceled) { return; }
    this._rejectWithCancelation();

    // eagerly advance index so that pending promise resolutions
    // are ignored
    this._index++;
    this._proceed(this._index, undefined);
  },

  /**
   * Returns a promise that resolves with the value returned
   * from the task's (generator) function, or rejects with
   * either the exception thrown from the task function, or
   * an error with a `.name` property with value `"TaskCancelation"`.
   *
   * @method then
   * @memberof TaskInstance
   * @instance
   * @return {Promise}
   */
  then:    forwardToInternalPromise('then'),

  /**
   * @method catch
   * @memberof TaskInstance
   * @instance
   * @return {Promise}
   */
  catch:   forwardToInternalPromise('catch'),

  /**
   * @method finally
   * @memberof TaskInstance
   * @instance
   * @return {Promise}
   */
  finally: forwardToInternalPromise('finally'),

  _rejectWithCancelation() {
    if (this.isCanceled) { return; }
    let error = new Error("TaskCancelation");
    error.name = "TaskCancelation";
    error.taskInstance = this;
    this._reject(error);
    this.set('isCanceled', true);
  },

  _reject(error) {
    this._defer.reject(error);
  },

  _defer: null,

  _proceed(index, nextValue, method) {
    this._dispose();
    Ember.run.once(this, this._takeStep, index, nextValue, method);
  },

  _hasBegunShutdown: false,
  _hasResolved: false,

  _finalize(value) {
    this.set('isFinished', true);
    this._defer.resolve(value);
    this._dispose();
  },

  _dispose() {
    if (this._disposable) {
      this._disposable.dispose();
      this._disposable = null;
    }
  },

  _takeSafeStep(nextValue, iteratorMethod) {
    try {
      return this.iterator[iteratorMethod](nextValue);
    } catch(e) {
      return { value: e, error: true };
    }
  },

  _takeStep(index, nextValue, method) {
    if (index !== this._index) { return; }

    let result;
    if (this.isCanceled &amp;&amp; !this._hasBegunShutdown) {
      this._hasBegunShutdown = true;
      if (this.hasStarted) {
        result = this._takeSafeStep(nextValue, 'return');
      } else {
        // calling .return on an unstarted generator iterator
        // doesn't do the intuitive thing, so just skip it.
        result = { done: true, value: undefined };
      }
    } else {
      result = this._takeSafeStep(nextValue, method || 'next');
    }

    let { done, value, error } = result;

    if (error) {
      this._finalize(Ember.RSVP.reject(value));
      return;
    } else {
      if (done &amp;&amp; value === undefined) {
        this.set('isFinished', true);
        this._finalize(nextValue);
        return;
      }
    }

    let observable = normalizeObservable(value);
    if (!observable) {
      // TODO: assert that user is doing something weird?
      this._proceed(index, value);
      return;
    }

    this._disposable = observable.subscribe(v => {
      this._proceed(index, v);
    }, error => {
      this._proceed(index, error, 'throw');
    }, () => {
      // TODO: test, and figure out what it means to yield
      // something that completes without producing a value.
    });
  },
});

function normalizeObservable(value) {
  if (!value) { return null; }

  if (value instanceof TaskInstance) {
    return createObservable(publish => {
      value.then(publish, publish.error);
      return () => {
        value.cancel();
      };
    });
  } else if (typeof value.then === 'function') {
    return createObservable(publish => {
      value.then(publish, publish.error);
      return value.__ec_dispose__;
    });
  } else if (typeof value.subscribe === 'function') {
    // TODO: check for scheduler interface for Rx rather than
    // creating another wrapping observable to schedule on run loop.
    return createObservable(publish => {
      return value.subscribe(publish, publish.error).dispose;
    });
  } else {
    return null;
  }
}

export default TaskInstance;

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Task.html">Task</a></li><li><a href="TaskInstance.html">TaskInstance</a></li><li><a href="TaskProperty.html">TaskProperty</a></li></ul><h3>Global</h3><ul><li><a href="global.html#all">all</a></li><li><a href="global.html#race">race</a></li><li><a href="global.html#task">task</a></li><li><a href="global.html#timeout">timeout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Feb 18 2016 13:02:53 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber-8520038fe7381ba8119956a342d21580.js" integrity="sha256-vMEFelUNCGXNj868DnUxt2Im0l1C69+oyrwR8jFMN4c= sha512-wMQT+ilyfMWGE+hfya4aHTkRssI1sZ4CANq+avFb+SRSfITBRUUxlSgAZC11+ry8dr+eMW2CgVJggPXncHTwEQ==" > </script>
</body>
</html>
